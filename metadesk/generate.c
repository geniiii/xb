// NOTE(geni): Really bad code, can probably be cleaned up using Metadesk's C helpers, once I figure out how to actually use most of them...

#include "md.h"
#include "md.c"

#define SHADER_INPUT_MAX   16
#define SHADER_OUTPUT_MAX  16
#define SHADER_UNIFORM_MAX 32
#define SHADERS_MAX        4096

typedef struct {
    MD_String8 name;

    MD_Node* version;

    MD_Node* input;
    MD_Node* output;
    MD_Node* uniforms;

    MD_Node* vertex;
    MD_Node* fragment;

    MD_b32 valid;
} ShaderInfo;

static int        shader_count;
static ShaderInfo shaders[SHADERS_MAX];

static MD_Arena* arena;

static void GenerateString(FILE* file, MD_Node* node) {
    fprintf(file, "\"");
    for (MD_u64 i = 0; i < node->string.size; ++i) {
        if (node->string.str[i] == '\n') {
            fprintf(file, "\\n\"\n\"");
        } else if (node->string.str[i] == '\r' &&
                   i + 1 < node->string.size && node->string.str[i + 1] == '\n') {
            // NOTE(mal): Step over CR when quoting CRLF newlines
        } else {
            fprintf(file, "%c", node->string.str[i]);
        }
    }
    fprintf(file, "\"");
}

static ShaderInfo ParseShaderInfo(MD_Node* shader) {
    ShaderInfo info = {
        .name = shader->string,
    };

    for (MD_EachNode(node, shader->first_child)) {
        if (MD_S8Match(node->string, MD_S8Lit("vertex"), MD_StringMatchFlag_CaseInsensitive)) {
            info.vertex = node->first_child;
        } else if (MD_S8Match(node->string, MD_S8Lit("fragment"), MD_StringMatchFlag_CaseInsensitive)) {
            info.fragment = node->first_child;
        } else if (MD_S8Match(node->string, MD_S8Lit("version"), MD_StringMatchFlag_CaseInsensitive)) {
            info.version = node->first_child;
        }
    }

    for (MD_EachNode(child, shader->first_tag)) {
        if (MD_S8Match(child->string, MD_S8Lit("Input"), MD_StringMatchFlag_CaseInsensitive)) {
            info.input = child;
        } else if (MD_S8Match(child->string, MD_S8Lit("Output"), MD_StringMatchFlag_CaseInsensitive)) {
            info.output = child;
        } else if (MD_S8Match(child->string, MD_S8Lit("Uniforms"), MD_StringMatchFlag_CaseInsensitive)) {
            info.uniforms = child;
        }
    }

    info.valid = !MD_NodeIsNil(info.vertex) && !MD_NodeIsNil(info.fragment) && !MD_NodeIsNil(info.input) && !MD_NodeIsNil(info.output);
    if (MD_NodeIsNil(info.vertex)) {
        MD_CodeLoc loc = MD_CodeLocFromNode(shader);
        MD_PrintMessage(stderr, loc, MD_MessageKind_FatalError,
                        MD_S8Lit("Shader has no vertex shader"));
    }
    if (MD_NodeIsNil(info.fragment)) {
        MD_CodeLoc loc = MD_CodeLocFromNode(shader);
        MD_PrintMessage(stderr, loc, MD_MessageKind_FatalError,
                        MD_S8Lit("Shader has no fragment shader"));
    }
    if (MD_NodeIsNil(info.input)) {
        MD_CodeLoc loc = MD_CodeLocFromNode(shader);
        MD_PrintMessage(stderr, loc, MD_MessageKind_FatalError,
                        MD_S8Lit("Shader has no inputs"));
    }
    if (MD_NodeIsNil(info.output)) {
        MD_CodeLoc loc = MD_CodeLocFromNode(shader);
        MD_PrintMessage(stderr, loc, MD_MessageKind_FatalError,
                        MD_S8Lit("Shader has no outputs"));
    }

    return info;
}

static void GenerateShaderFile(FILE* file) {
    // NOTE(geni): Generate shader file

    //~ Header comment
    puts("Generating header comment");
    fputs(
        "/* This file was generated by xtal-gen-shaders, don't edit! */\n"
        "\n",
        file);

    //~ Shader enum
    puts("Generating shader enum");
    fputs("typedef enum {\n", file);
    for (int i = 0; i < shader_count; ++i) {
        fprintf(file, "XGL_SType_%.*s,\n", MD_S8VArg(shaders[i].name));
    }
    fputs("XGL_SType_Count,\n", file);
    fputs(
        "} XGL_SType;\n"
        "\n",
        file);

    //~ Uniform enum
    puts("Generating uniform enum");
    fputs("typedef enum {\n", file);
    for (int i = 0; i < shader_count; ++i) {
        if (shaders[i].uniforms == NULL) {
            continue;
        }

        MD_Node* uniform = shaders[i].uniforms->first_child;
        fprintf(file, "XGL_SType_%.*s_U_%.*s = 0,\n", MD_S8VArg(shaders[i].name), MD_S8VArg(uniform->string));
        for (uniform = uniform->next; !MD_NodeIsNil(uniform); uniform = uniform->next) {
            MD_String8 uniform_name = MD_S8Copy(arena, uniform->string);
            for (int j = 0; j < uniform_name.size; ++j) {
                if (uniform_name.str[j] == '.') {
                    uniform_name.str[j] = '_';
                }
            }
            fprintf(file, "XGL_SType_%.*s_U_%.*s,\n", MD_S8VArg(shaders[i].name), MD_S8VArg(uniform_name));
        }
    }
    fputs(
        "} XGL_SType_U;\n"
        "\n",
        file);

    // NOTE(geni): Generate array (really badly)
    puts("Generating shader array");
    fprintf(file,
            "#define XGL_SHADERINFO_INPUT_MAX %d\n"
            "#define XGL_SHADERINFO_OUTPUT_MAX %d\n"
            "#define XGL_SHADERINFO_UNIFORM_MAX %d\n"
            "\n"

            "typedef struct {\n"
            "	GLint loc;\n"
            "	String8 name;\n"
            "} XGL_VertexAttr;\n"
            "\n"

            "typedef struct {\n"
            "	String8 name;\n"
            "	String8 vertex;\n"
            "	String8 fragment;\n"
            "	u32 input_count;\n"
            "	u32 output_count;\n"
            "    u32 uniform_count;\n"
            "	XGL_VertexAttr inputs[XGL_SHADERINFO_INPUT_MAX];\n"
            "	XGL_VertexAttr outputs[XGL_SHADERINFO_INPUT_MAX];\n"
            "	XGL_VertexAttr uniforms[XGL_SHADERINFO_UNIFORM_MAX];\n"
            "} XGL_ShaderInfo;\n"
            "\n"

            "global XGL_ShaderInfo xgl_generated_shaders[] = {\n",
            SHADER_INPUT_MAX, SHADER_OUTPUT_MAX, SHADER_UNIFORM_MAX);
    for (int i = 0; i < shader_count; ++i) {
        ShaderInfo* shader = &shaders[i];

        printf("Generating shader \"%.*s\"\n", MD_S8VArg(shader->name));

        fprintf(file,
                "    [XGL_SType_%.*s] = {\n"
                "        .name = S8LitComp(\"%.*s\"),\n"
                "        .inputs = {\n",
                MD_S8VArg(shader->name), MD_S8VArg(shader->name));

        //~ Inputs
        int input_count = 0;
        for (MD_Node* input = shader->input->first_child; !MD_NodeIsNil(input); input = input->next, ++input_count) {
            fprintf(file, "            { %d, S8LitComp(\"%.*s\") },\n", input_count, MD_S8VArg(input->string));
        }
        fputs(
            "        },\n"
            "        .outputs = {\n",
            file);
        if (input_count > SHADER_INPUT_MAX) {
            MD_CodeLoc loc = MD_CodeLocFromNode(shader->input);
            MD_PrintMessage(stderr, loc, MD_MessageKind_FatalError,
                            MD_S8Lit("Input count > SHADER_INPUT_MAX"));
        }

        //~ Outputs
        int output_count = 0;
        for (MD_Node* output = shader->output->first_child; !MD_NodeIsNil(output); output = output->next, ++output_count) {
            fprintf(file,
                    "            { %d, S8LitComp(\"%.*s\") },\n",
                    output_count, MD_S8VArg(output->string));
        }
        fputs("        },\n",
              file);
        if (output_count > SHADER_INPUT_MAX) {
            MD_CodeLoc loc = MD_CodeLocFromNode(shader->output);
            MD_PrintMessage(stderr, loc, MD_MessageKind_FatalError,
                            MD_S8Lit("Output count > SHADER_OUTPUT_MAX"));
        }

        //~ Uniforms
        if (shader->uniforms) {
            fputs("        .uniforms = {\n",
                  file);
            int uniform_count = 0;
            for (MD_Node* uniform = shader->uniforms->first_child; !MD_NodeIsNil(uniform); uniform = uniform->next, ++uniform_count) {
                fprintf(file, "            { -1, S8LitComp(\"%.*s\") },\n", MD_S8VArg(uniform->string));
            }
            if (uniform_count > SHADER_UNIFORM_MAX) {
                MD_CodeLoc loc = MD_CodeLocFromNode(shader->uniforms);
                MD_PrintMessage(stderr, loc, MD_MessageKind_FatalError,
                                MD_S8Lit("Uniform count > SHADER_UNIFORM_MAX"));
            }
            fprintf(file,
                    "        },\n"
                    "        .uniform_count = %d,\n",
                    uniform_count);
        }

        //~ Vertex
        fprintf(file,
                "        .input_count = %d,\n"
                "        .output_count = %d,\n"
                "        .vertex = S8LitComp(",
                input_count, output_count);
        if (MD_NodeIsNil(shader->version)) {
            // NOTE(geni): Default to GLSL 4.2 core
            fputs("\"#version 420 core\\n\"\n", file);
        } else {
            fprintf(file, "\"#version %.*s", MD_S8VArg(shader->version->string));
        }
        fputs("\"precision mediump float;\\n\"\n", file);
        GenerateString(file, shader->vertex);

        //~ Fragment
        fputs(
            "),\n"
            "        .fragment = S8LitComp(",
            file);
        if (MD_NodeIsNil(shader->version)) {
            // NOTE(geni): Default to GLSL 4.2 core
            fputs("\"#version 420 core\\n\"\n", file);
        } else {
            fprintf(file, "\"#version %.*s", MD_S8VArg(shader->version->string));
        }
        fputs("\"precision mediump float;\\n\"\n", file);
        GenerateString(file, shader->fragment);

        //~ End
        fputs(
            "),\n"
            "    },\n",
            file);
    }
    fputs("};\n", file);
}

int main(int argument_count, char** arguments) {
    arena               = MD_ArenaAlloc();
    MD_CmdLine cmd_line = MD_MakeCmdLineFromOptions(arena, MD_StringListFromArgCV(arena, argument_count, arguments));

    for (MD_String8Node* filename_node = cmd_line.inputs.first; filename_node; filename_node = filename_node->next) {
        MD_String8 filename = filename_node->string;

        MD_String8     file_contents = MD_LoadEntireFile(arena, filename);
        MD_ParseResult parse         = MD_ParseWholeString(arena, filename, file_contents);
        if (file_contents.str == 0) {
            MD_CodeLoc loc = MD_CodeLocFromNode(parse.node);
            MD_PrintMessage(stderr, loc, MD_MessageKind_FatalError,
                            MD_S8Fmt(arena, "Could not read file \"%S\"", filename));
            return 1;
        }

        // NOTE(geni): Skip over file if failed to parse
        if (parse.errors.first) {
            for (MD_Message* error = parse.errors.first; error; error = error->next) {
                MD_CodeLoc loc = MD_CodeLocFromNode(error->node);
                MD_PrintMessage(stderr, loc, error->kind, error->string);
            }
            continue;
        }

        for (MD_EachNode(root, parse.node->first_child)) {
            if (MD_NodeHasTag(root, MD_S8Lit("Shader"), 0)) {
                ShaderInfo info = ParseShaderInfo(root);
                if (info.valid) {
                    shaders[shader_count++] = info;
                }
            }
        }
    }

    printf("Found %d valid shaders\n", shader_count);
    if (shader_count > 0) {
        MD_String8List values             = MD_CmdLineValuesFromString(cmd_line, MD_S8Lit("shader_output"));
        MD_String8     shader_output_file = MD_S8ListJoin(arena, values, 0);
        FILE*          file               = fopen((const char*) MD_S8Copy(arena, shader_output_file).str, "wb");
        if (!file) {
            puts("Failed to open shader output file, forgot argument \"shader_output\"?");
        } else {
            GenerateShaderFile(file);
            fclose(file);
        }
    }
}
